<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>于贵洋的博客</title>
  <subtitle>BI、数据分析</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-27T15:14:31.608Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>于贵洋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>numpy手册(1)-ndarray</title>
    <link href="http://yoursite.com/2017/08/02/numpy-handbook-01/"/>
    <id>http://yoursite.com/2017/08/02/numpy-handbook-01/</id>
    <published>2017-08-02T13:59:00.000Z</published>
    <updated>2017-08-27T15:14:31.608Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们算是简单入门了Pandas，numpy也是数据分析中常用的，这里我们也来简单学习下。</p>
<h1 id="1-numpy基本介绍"><a href="#1-numpy基本介绍" class="headerlink" title="1.numpy基本介绍"></a>1.numpy基本介绍</h1><blockquote class="blockquote-center"><br>numpy是Python的一种开源数值计算扩展，这种工具可以用来存储和处理大型矩阵。一个用Python实现的科学计算包。<br>（–百度百科）<br></blockquote>

<p>numpy有2种基本对象，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ndarray（N-dimensional array object）和 ufunc（universal function object）</div></pre></td></tr></table></figure></p>
<p>ndarray是存储单一数据类型的多维数组，ufunc是能够对数组进行处理的函数。</p>
<h1 id="2-ndarray"><a href="#2-ndarray" class="headerlink" title="2.ndarray"></a>2.ndarray</h1><p>我们先来看看这个数组<br>首先，我们得引入numpy<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div></pre></td></tr></table></figure></p>
<h2 id="2-1-创建"><a href="#2-1-创建" class="headerlink" title="2.1 创建"></a>2.1 创建</h2><p>数组初始化的话有很多方式：Array creation routines<br>我们可以直接使用list来初始化，array有很多的属性，比如大小，维度，元素个数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div><div class="line">b = np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</div><div class="line">c = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</div><div class="line"></div><div class="line">print(a,type(a),<span class="string">',shape:'</span>,a.shape,<span class="string">',ndim:'</span>,a.ndim,<span class="string">',size:'</span>,a.size)</div><div class="line">print(b,type(b),<span class="string">',shape:'</span>,b.shape,<span class="string">',ndim:'</span>,b.ndim,<span class="string">',size:'</span>,b.size)</div><div class="line">print(c,type(c),<span class="string">',shape:'</span>,c.shape,<span class="string">',ndim:'</span>,c.ndim,<span class="string">',size:'</span>,c.size)</div></pre></td></tr></table></figure></p>
<p><img src="http://7xl61k.com1.z0.glb.clouddn.com/numpy-handbook-01-01.png-blog.photo" alt="numpy-handbook-01-01"></p>
<p>这里呢，我们定义了一维数组和二维数组，比如c，是3行3列的2维数组，元素个数是9个<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">numpy.array(object, dtype=<span class="keyword">None</span>, copy=<span class="keyword">True</span>, order=<span class="string">'K'</span>, subok=<span class="keyword">False</span>, ndmin=<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<p>这里，我们再说下这个shape，这个属性可以修改<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#原来是4行3列</span></div><div class="line">c = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>]])</div><div class="line">print(c)</div><div class="line"><span class="comment">#我们改为3行4列</span></div><div class="line">c.shape=(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">print(c)</div><div class="line"><span class="comment">#改为2行6列</span></div><div class="line">c.shape=(<span class="number">2</span>,<span class="number">6</span>)</div><div class="line">print(c)</div></pre></td></tr></table></figure></p>
<p><img src="http://7xl61k.com1.z0.glb.clouddn.com/numpy-handbook-01-02.png-blog.photo" alt="numpy-handbook-01-02"></p>
<p>这里需要注意下，如果某个轴的元素为-1，将根据数组元素的个数，自动计算长度<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">c.shape=(<span class="number">1</span>,<span class="number">-1</span>)</div><div class="line">print(c)</div><div class="line">c.shape=(<span class="number">-1</span>,<span class="number">1</span>)</div><div class="line">print(c)</div></pre></td></tr></table></figure></p>
<p><img src="http://7xl61k.com1.z0.glb.clouddn.com/numpy-handbook-01-03.png-blog.photo" alt="numpy-handbook-01-03"></p>
<p>这里的shape是改变原来的数组，另一个method，可以创建一个改变shape的新数组，而原数组保持不变<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">c = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>]])</div><div class="line">print(<span class="string">'c:'</span>,c)</div><div class="line">d = c.reshape(<span class="number">2</span>,<span class="number">6</span>)</div><div class="line">print(<span class="string">'c:'</span>,c)</div><div class="line">print(<span class="string">'d:'</span>,d)</div></pre></td></tr></table></figure></p>
<p><img src="http://7xl61k.com1.z0.glb.clouddn.com/numpy-handbook-01-04.png-blog.photo" alt="numpy-handbook-01-04"></p>
<p>这里要注意的是，c和d共享内存数据存储内存区域，c变了，d也会变<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">print(c[<span class="number">0</span>])</div><div class="line"><span class="comment">#修改c[0]</span></div><div class="line">c[<span class="number">0</span>]=[<span class="number">-9</span>,<span class="number">-8</span>,<span class="number">-3</span>]</div><div class="line">print(<span class="string">'c:'</span>,c)</div><div class="line">print(<span class="string">'d:'</span>,d)</div></pre></td></tr></table></figure></p>
<p><img src="http://7xl61k.com1.z0.glb.clouddn.com/numpy-handbook-01-05.png-blog.photo" alt="numpy-handbook-01-05"></p>
<p>我们可以通过dtype来获取元素的类型，我们可以在初始化的时候，指定dtype<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">c = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div><div class="line">print(c.dtype) <span class="comment">#int32</span></div><div class="line"></div><div class="line">d = np.array([<span class="number">1.1</span>,<span class="number">3.3</span>])</div><div class="line">print(d.dtype) <span class="comment">#float64</span></div></pre></td></tr></table></figure></p>
<p>下面，我们来看看常用的初始化方法</p>
<h3 id="arange"><a href="#arange" class="headerlink" title="arange"></a>arange</h3><p>通过指定开始值，结束值和步长来创建一维数组，这里不包过终值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">arange([start,] stop[, step,], dtype=<span class="keyword">None</span>)</div><div class="line"></div><div class="line">np.arange(<span class="number">3</span>)</div><div class="line">Out[<span class="number">51</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</div><div class="line"></div><div class="line">np.arange(<span class="number">1</span>,<span class="number">10</span>,<span class="number">3</span>)</div><div class="line">Out[<span class="number">52</span>]: array([<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>])</div></pre></td></tr></table></figure></p>
<h3 id="linspace"><a href="#linspace" class="headerlink" title="linspace"></a>linspace</h3><p>通过指定开始值，终值和元素个数，来创建数组，这里包括终值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>)</div><div class="line">Out[<span class="number">53</span>]: array([  <span class="number">1.</span>  ,   <span class="number">3.25</span>,   <span class="number">5.5</span> ,   <span class="number">7.75</span>,  <span class="number">10.</span>  ])</div><div class="line"></div><div class="line">np.linspace(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line">Out[<span class="number">54</span>]: array([ <span class="number">1.</span> ,  <span class="number">1.5</span>,  <span class="number">2.</span> ])</div></pre></td></tr></table></figure></p>
<h3 id="np-zeros-np-ones"><a href="#np-zeros-np-ones" class="headerlink" title="np.zeros,np.ones"></a>np.zeros,np.ones</h3><p>这2个函数可以初始化指定长度或形状的全0或全1的数组<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">np.ones(<span class="number">3</span>)</div><div class="line">Out[<span class="number">202</span>]: array([ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>])</div><div class="line"></div><div class="line">np.ones([<span class="number">2</span>,<span class="number">2</span>])</div><div class="line">Out[<span class="number">203</span>]: </div><div class="line">array([[ <span class="number">1.</span>,  <span class="number">1.</span>],</div><div class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>]])</div><div class="line"></div><div class="line">np.zeros(<span class="number">5</span>)</div><div class="line">Out[<span class="number">204</span>]: array([ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>])</div><div class="line"></div><div class="line">np.zeros([<span class="number">4</span>,<span class="number">3</span>])</div><div class="line">Out[<span class="number">205</span>]: </div><div class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</div><div class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</div><div class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</div><div class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</div></pre></td></tr></table></figure></p>
<h3 id="np-empty"><a href="#np-empty" class="headerlink" title="np.empty"></a>np.empty</h3><p>可以创建一个没有任何具体值得数组<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">np.empty(<span class="number">2</span>)</div><div class="line">Out[<span class="number">211</span>]: array([  <span class="number">7.74860419e-304</span>,   <span class="number">7.74860419e-304</span>])</div><div class="line"></div><div class="line">np.empty(<span class="number">2</span>,dtype=int)</div><div class="line">Out[<span class="number">214</span>]: array([        <span class="number">-1</span>, <span class="number">2147483647</span>])</div><div class="line"></div><div class="line">np.empty((<span class="number">3</span>,<span class="number">3</span>),dtype=np.float64)</div><div class="line">Out[<span class="number">215</span>]: </div><div class="line">array([[  <span class="number">4.94065646e-324</span>,   <span class="number">9.88131292e-324</span>,   <span class="number">1.48219694e-323</span>],</div><div class="line">       [  <span class="number">1.97626258e-323</span>,   <span class="number">2.47032823e-323</span>,   <span class="number">2.96439388e-323</span>],</div><div class="line">       [  <span class="number">3.45845952e-323</span>,   <span class="number">3.95252517e-323</span>,   <span class="number">4.44659081e-323</span>]])</div></pre></td></tr></table></figure></p>
<p>这要注意下，empty初始化的都是没有意思的值，不一定会初始化为0</p>
<p><img src="http://7xl61k.com1.z0.glb.clouddn.com/numpy-handbook-01-06.png-blog.photo" alt="numpy-handbook-01-06"></p>
<h2 id="2-2-存取元素"><a href="#2-2-存取元素" class="headerlink" title="2.2 存取元素"></a>2.2 存取元素</h2><p>这里直接粘贴一个例子，原始教程在这：<a href="http://old.sebug.net/paper/books/scipydoc/numpy_intro.html" target="_blank" rel="external">http://old.sebug.net/paper/books/scipydoc/numpy_intro.html</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">10</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">5</span>]    <span class="comment"># 用整数作为下标可以获取数组中的某个元素</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">3</span>:<span class="number">5</span>]  <span class="comment"># 用范围作为下标获取数组的一个切片，包括a[3]不包括a[5]</span></div><div class="line">array([<span class="number">3</span>, <span class="number">4</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">5</span>]   <span class="comment"># 省略开始下标，表示从a[0]开始</span></div><div class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">-1</span>]  <span class="comment"># 下标可以使用负数，表示从数组后往前数</span></div><div class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">4</span>] = <span class="number">100</span>,<span class="number">101</span>    <span class="comment"># 下标还可以用来修改元素的值</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a</div><div class="line">array([  <span class="number">0</span>,   <span class="number">1</span>, <span class="number">100</span>, <span class="number">101</span>,   <span class="number">4</span>,   <span class="number">5</span>,   <span class="number">6</span>,   <span class="number">7</span>,   <span class="number">8</span>,   <span class="number">9</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">-1</span>:<span class="number">2</span>]   <span class="comment"># 范围中的第三个参数表示步长，2表示隔一个元素取一个元素</span></div><div class="line">array([  <span class="number">1</span>, <span class="number">101</span>,   <span class="number">5</span>,   <span class="number">7</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[::<span class="number">-1</span>] <span class="comment"># 省略范围的开始下标和结束下标，步长为-1，整个数组头尾颠倒</span></div><div class="line">array([  <span class="number">9</span>,   <span class="number">8</span>,   <span class="number">7</span>,   <span class="number">6</span>,   <span class="number">5</span>,   <span class="number">4</span>, <span class="number">101</span>, <span class="number">100</span>,   <span class="number">1</span>,   <span class="number">0</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">5</span>:<span class="number">1</span>:<span class="number">-2</span>] <span class="comment"># 步长为负数时，开始下标必须大于结束下标</span></div><div class="line">array([  <span class="number">5</span>, <span class="number">101</span>])</div></pre></td></tr></table></figure></p>
<p>就2维数组来说</p>
<p><img src="http://7xl61k.com1.z0.glb.clouddn.com/numpy-handbook-01-07.png-blog.photo" alt="numpy-handbook-01-07"></p>
<p>这是基本的获取方式，还有些高级的方法</p>
<h3 id="使用整数序列"><a href="#使用整数序列" class="headerlink" title="使用整数序列"></a>使用整数序列</h3><p>这里简单来2个练习，原文例子很多，就是通过下标来筛选数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">a = np.arange(<span class="number">-5</span>,<span class="number">5</span>,<span class="number">1</span>)</div><div class="line"></div><div class="line">a</div><div class="line">Out[<span class="number">68</span>]: array([<span class="number">-5</span>, <span class="number">-4</span>, <span class="number">-3</span>, <span class="number">-2</span>, <span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>])</div><div class="line"></div><div class="line">a[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]]</div><div class="line">Out[<span class="number">69</span>]: array([<span class="number">-4</span>, <span class="number">-2</span>,  <span class="number">0</span>])</div><div class="line"></div><div class="line"><span class="comment">### 使用布尔数组</span></div><div class="line"></div><div class="line">按照传入的布尔数组，只有为<span class="keyword">True</span>的才返回，也叫布尔型索引</div><div class="line">``` python</div><div class="line">a=np.array([<span class="number">-3</span>,<span class="number">1</span>,<span class="number">5</span>])</div><div class="line"></div><div class="line">a</div><div class="line">Out[<span class="number">72</span>]: array([<span class="number">-3</span>,  <span class="number">1</span>,  <span class="number">5</span>])</div><div class="line"></div><div class="line">a[[<span class="keyword">False</span>,<span class="keyword">True</span>,<span class="keyword">False</span>]]</div><div class="line">Out[<span class="number">73</span>]: array([<span class="number">1</span>])</div><div class="line"></div><div class="line">a[[<span class="keyword">True</span>,<span class="keyword">False</span>,<span class="keyword">True</span>]]</div><div class="line">Out[<span class="number">74</span>]: array([<span class="number">-3</span>,  <span class="number">5</span>])</div></pre></td></tr></table></figure></p>
<h1 id="3-附录（参考资料）"><a href="#3-附录（参考资料）" class="headerlink" title="3.附录（参考资料）"></a>3.附录（参考资料）</h1><p>文档：<br><a href="https://docs.scipy.org/doc/numpy-dev/reference/index.html#reference" target="_blank" rel="external">https://docs.scipy.org/doc/numpy-dev/reference/index.html#reference</a></p>
<p><a href="http://old.sebug.net/paper/books/scipydoc/numpy_intro.html" target="_blank" rel="external">numpy快速处理数据</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们算是简单入门了Pandas，numpy也是数据分析中常用的，这里我们也来简单学习下。&lt;/p&gt;
&lt;h1 id=&quot;1-numpy基本介绍&quot;&gt;&lt;a href=&quot;#1-numpy基本介绍&quot; class=&quot;headerlink&quot; title=&quot;1.numpy基本介绍&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="Python-Numpy" scheme="http://yoursite.com/categories/Python-Numpy/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Numpy" scheme="http://yoursite.com/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>Cognos资料汇总贴</title>
    <link href="http://yoursite.com/2017/08/01/cognos-doc-main/"/>
    <id>http://yoursite.com/2017/08/01/cognos-doc-main/</id>
    <published>2017-08-01T13:59:00.000Z</published>
    <updated>2017-08-27T14:52:03.630Z</updated>
    
    <content type="html"><![CDATA[<p>以前搞过Cognos，写过很多基础的教程，应该是14年的样子，都在CSDN上，这里贴个汇总贴吧，想要看的同学可以去看看，希望有帮助。</p>
<p>ReportStudio入门教程：<a href="http://blog.csdn.net/column/details/ygy-reportstudio.html" target="_blank" rel="external">http://blog.csdn.net/column/details/ygy-reportstudio.html</a></p>
<p>Framework Manage入门教程：<a href="http://blog.csdn.net/column/details/ygy-frameworkmanager.html" target="_blank" rel="external">http://blog.csdn.net/column/details/ygy-frameworkmanager.html</a></p>
<p>Cognos函数手册：<a href="http://blog.csdn.net/column/details/ygy-cognos-function.html" target="_blank" rel="external">http://blog.csdn.net/column/details/ygy-cognos-function.html</a></p>
<p>Cognos相关的其他资料（主页不同的类别下看看）：<a href="http://blog.csdn.net/yuguiyang1990" target="_blank" rel="external">http://blog.csdn.net/yuguiyang1990</a></p>
<p><img src="http://7xl61k.com1.z0.glb.clouddn.com/cognos-doc-main.png-blog.photo" alt="cognos-doc-main.png"></p>
<p>好了，感兴趣的同学，可以自行去看看，好久不搞了，估计有疑问也解决不了了…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前搞过Cognos，写过很多基础的教程，应该是14年的样子，都在CSDN上，这里贴个汇总贴吧，想要看的同学可以去看看，希望有帮助。&lt;/p&gt;
&lt;p&gt;ReportStudio入门教程：&lt;a href=&quot;http://blog.csdn.net/column/details/y
    
    </summary>
    
      <category term="数据可视化-Cognos" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-Cognos/"/>
    
    
      <category term="Cognos" scheme="http://yoursite.com/tags/Cognos/"/>
    
      <category term="数据可视化" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Kettle手册（十二）- 控件使用-从步骤插入数据</title>
    <link href="http://yoursite.com/2017/04/14/Kettle-handbook-12/"/>
    <id>http://yoursite.com/2017/04/14/Kettle-handbook-12/</id>
    <published>2017-04-14T03:24:44.000Z</published>
    <updated>2017-08-27T14:36:07.845Z</updated>
    
    <content type="html"><![CDATA[<p>这里介绍一个控件的小功能，也是最近才发现的，之前在“表输入”中要使用参数的话，一般都是使用变量，<br>其实，还有个功能也可以尝试使用<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-12-01.png-blog.photo" alt="Kettle-handbook-12-01.png"><br>整体流程就是这样，我们第一个 query_paramter，就是查询了我们想设置的参数<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-12-02.png-blog.photo" alt="Kettle-handbook-12-02.png"><br>然后，就是我们真正需要的，我们再表输入中，使用 “?”来占位，然后“从步骤插入数据”，选择上一个步骤，然后会将数据替换占位符<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-12-03.png-blog.photo" alt="Kettle-handbook-12-03.png"><br>最后，我们将文件导出即可，奥对了，我们可以改成日志控件，直接输出查看<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-12-04.png-blog.photo" alt="Kettle-handbook-12-04.png"><br>刚刚，上面还有一个“执行每一行”，这个就是，如果我们有多个参数，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-12-05.png-blog.photo" alt="Kettle-handbook-12-05.png"><br>就可以使用这个参数了，很方便，好了，就介绍到这里先。<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-12-06.png-blog.photo" alt="Kettle-handbook-12-06.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里介绍一个控件的小功能，也是最近才发现的，之前在“表输入”中要使用参数的话，一般都是使用变量，&lt;br&gt;其实，还有个功能也可以尝试使用&lt;br&gt;&lt;img src=&quot;http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-12
    
    </summary>
    
      <category term="ETL-Kettle" scheme="http://yoursite.com/categories/ETL-Kettle/"/>
    
    
      <category term="Kettle" scheme="http://yoursite.com/tags/Kettle/"/>
    
  </entry>
  
  <entry>
    <title>Kettle手册（十一）- 用PGP加密、加密文件</title>
    <link href="http://yoursite.com/2017/04/11/Kettle-handbook-11/"/>
    <id>http://yoursite.com/2017/04/11/Kettle-handbook-11/</id>
    <published>2017-04-11T03:24:44.000Z</published>
    <updated>2017-08-27T14:31:04.826Z</updated>
    
    <content type="html"><![CDATA[<p>看到有同学提问，以前也没用过，百度了一下，找了些资料，这里记录下。</p>
<h1 id="1-安装gpg4win"><a href="#1-安装gpg4win" class="headerlink" title="1. 安装gpg4win"></a>1. 安装gpg4win</h1><p>这个gpg4win是干嘛的呢，我们可以去他的官网看看：<a href="https://www.gpg4win.org/index.html" target="_blank" rel="external">gpg4win</a><br>目前，只知道他是加密的，这个是对Windows平台使用的<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-01.png-blog.photo" alt="Kettle-handbook-11-01.png"><br>这里可能还有个PGP的概念，看看百度百科<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-02.png-blog.photo" alt="Kettle-handbook-11-02.png"></p>
<a id="more"></a>
<p>好了，具体概念，大家可以自行找找，我们下载下来，然后安装一下即可<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-03.png-blog.photo" alt="Kettle-handbook-11-03.png"><br>这个是昨天安装的，就不粘贴步骤了，安装完后，我们要先创建一个证书的东西，我们打开这个管理界面<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-04.png-blog.photo" alt="Kettle-handbook-11-04.png"><br>打开后，是这样一个界面，（网上有这个的安装配置教程，这里也简单介绍下，不清楚的可以再百度看看）<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-05.png-blog.photo" alt="Kettle-handbook-11-05.png"><br>我们新建一个Certificate<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-06.png-blog.photo" alt="Kettle-handbook-11-06.png"><br>我们选择一个加密方式，使用第一个就可以了<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-07.png-blog.photo" alt="Kettle-handbook-11-07.png"><br>我们输入些基本信息然后next就可以<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-08.png-blog.photo" alt="Kettle-handbook-11-08.png"><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-09.png-blog.photo" alt="Kettle-handbook-11-09.png"><br>然后，我们得输入一段密钥<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-10.png-blog.photo" alt="Kettle-handbook-11-10.png"><br>好了，这里，就配置完成了<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-11.png-blog.photo" alt="Kettle-handbook-11-11.png"><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-12.png-blog.photo" alt="Kettle-handbook-11-12.png"></p>
<h1 id="2-用PGP加密文件"><a href="#2-用PGP加密文件" class="headerlink" title="2. 用PGP加密文件"></a>2. 用PGP加密文件</h1><p>好了，这里，我们新建一个作业，我们主要使用这2个控件<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-13.png-blog.photo" alt="Kettle-handbook-11-13.png"><br>一个很简单的流程，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-14.png-blog.photo" alt="Kettle-handbook-11-14.png"><br>我们做些简单的配置，<br>一个是GPG的目录（就是我们上面安装的那个）<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-15.png-blog.photo" alt="Kettle-handbook-11-15.png"><br>还有就是，我们的要加密的文件和一个目标文件名，注意，这里我们得填写一下“用户ID”，就是我们前面新建的那个用户名就可以了<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-16.png-blog.photo" alt="Kettle-handbook-11-16.png"><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-17.png-blog.photo" alt="Kettle-handbook-11-17.png"><br>这里，可以勾选一下，目标是一个文件<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-18.png-blog.photo" alt="Kettle-handbook-11-18.png"><br>好了，然后，我们执行下就可以了<br>我们源文件：<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-19.png-blog.photo" alt="Kettle-handbook-11-19.png"><br>加密后的文件：<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-20.png-blog.photo" alt="Kettle-handbook-11-20.png"><br>下面，我们再看看，怎样解密</p>
<h1 id="3-用PGP解密文件"><a href="#3-用PGP解密文件" class="headerlink" title="3. 用PGP解密文件"></a>3. 用PGP解密文件</h1><p>知道了加密，解密也是一样的，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-21.png-blog.photo" alt="Kettle-handbook-11-21.png"><br>这里的话，配置和上面差不多，这里，我们要填写一个“密钥”，就是我们上面创建时，输入的一个密码<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-22.png-blog.photo" alt="Kettle-handbook-11-22.png"><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-23.png-blog.photo" alt="Kettle-handbook-11-23.png"><br>我们运行一下，解密后，是一样的<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-24.png-blog.photo" alt="Kettle-handbook-11-24.png"><br>好了，就简单介绍到这里</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到有同学提问，以前也没用过，百度了一下，找了些资料，这里记录下。&lt;/p&gt;
&lt;h1 id=&quot;1-安装gpg4win&quot;&gt;&lt;a href=&quot;#1-安装gpg4win&quot; class=&quot;headerlink&quot; title=&quot;1. 安装gpg4win&quot;&gt;&lt;/a&gt;1. 安装gpg4win&lt;/h1&gt;&lt;p&gt;这个gpg4win是干嘛的呢，我们可以去他的官网看看：&lt;a href=&quot;https://www.gpg4win.org/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gpg4win&lt;/a&gt;&lt;br&gt;目前，只知道他是加密的，这个是对Windows平台使用的&lt;br&gt;&lt;img src=&quot;http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-01.png-blog.photo&quot; alt=&quot;Kettle-handbook-11-01.png&quot;&gt;&lt;br&gt;这里可能还有个PGP的概念，看看百度百科&lt;br&gt;&lt;img src=&quot;http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-11-02.png-blog.photo&quot; alt=&quot;Kettle-handbook-11-02.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ETL-Kettle" scheme="http://yoursite.com/categories/ETL-Kettle/"/>
    
    
      <category term="Kettle" scheme="http://yoursite.com/tags/Kettle/"/>
    
  </entry>
  
  <entry>
    <title>Kettle手册（十）- 跨库查询</title>
    <link href="http://yoursite.com/2017/04/10/Kettle-handbook-10/"/>
    <id>http://yoursite.com/2017/04/10/Kettle-handbook-10/</id>
    <published>2017-04-10T03:24:44.000Z</published>
    <updated>2017-08-27T14:18:29.979Z</updated>
    
    <content type="html"><![CDATA[<p>Kettle整体使用起来，还是很方便的，熟悉应用了之后，就是对控件的熟悉和使用了，只要思路有了，就是整合下Kettle中各个控件的使用就行。<br>这里，简单介绍下一个“跨库查询”的控件。<br>有的时候，我们一个脚本，可能只是临时性的，或者需要实时的去查一下，同步到数仓的话，可能不太方便，我们就可以使用跨库查询的控件<br>用到的表信息<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-10-01.png-blog.photo" alt="Kettle-handbook-10-01.png"><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-10-02.png-blog.photo" alt="Kettle-handbook-10-02.png"></p>
<a id="more"></a>
<h1 id="1-数据库连接-Database-Join"><a href="#1-数据库连接-Database-Join" class="headerlink" title="1. 数据库连接(Database Join)"></a>1. 数据库连接(Database Join)</h1><p>我们先用这个控件来实现一下<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-10-03.png-blog.photo" alt="Kettle-handbook-10-03.png"><br>用起来也很简单<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-10-04.png-blog.photo" alt="Kettle-handbook-10-04.png"><br>表输入：是我们第一个库中的SQL<br>数据库连接：是我们另一个库的SQL<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-10-05.png-blog.photo" alt="Kettle-handbook-10-05.png"><br>我们用关联的字段放在where条件后，使用“?”来占位，并在下面，选择要传入的参数<br>默认的话，是JOIN，我们也可以勾选Outer Join，<br>然后，我们看下，输出就行<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-10-06.png-blog.photo" alt="Kettle-handbook-10-06.png"><br>这是后面导出的文件，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-10-07.png-blog.photo" alt="Kettle-handbook-10-07.png"><br>这里，我们就简单实现了跨库的查询</p>
<h1 id="2-数据库查询"><a href="#2-数据库查询" class="headerlink" title="2. 数据库查询"></a>2. 数据库查询</h1><p>我们再来看另一个控件，“数据库查询”，这个控件同样可以实现跨库，但是有一个小问题<br>首先，我们使用上一次的数据来看<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-10-08.png-blog.photo" alt="Kettle-handbook-10-08.png"><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-10-09.png-blog.photo" alt="Kettle-handbook-10-09.png"><br>我们执行下，结果看上去是一样的<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-10-10.png-blog.photo" alt="Kettle-handbook-10-10.png"><br>这其实有个隐藏的问题，我们再增加几条记录看看<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-10-11.png-blog.photo" alt="Kettle-handbook-10-11.png"><br>比如：现在1号有2条记录，正常的话，我们导出也是要有2条的<br>我们执行下看看<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-10-12.png-blog.photo" alt="Kettle-handbook-10-12.png"><br>我们会看到，数据并没有增加，这是控件导致的，<br>先获取左边的结果集，然后一条一条去右边匹配；匹配到第一条记录后，就会跳出，直接去匹配下一个，所以，我们有2条记录，也只会找到第一个。<br>这并不是我们想要的，我们再试下第一个控件<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-10-13.png-blog.photo" alt="Kettle-handbook-10-13.png"><br>使用这个“数据库查询”控件的话，可以通过将1-N关系汇总，将N的一方，放在前面<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-10-14.png-blog.photo" alt="Kettle-handbook-10-14.png"><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-10-15.png-blog.photo" alt="Kettle-handbook-10-15.png"><br>最后的结果也是可以的<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-10-16.png-blog.photo" alt="Kettle-handbook-10-16.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kettle整体使用起来，还是很方便的，熟悉应用了之后，就是对控件的熟悉和使用了，只要思路有了，就是整合下Kettle中各个控件的使用就行。&lt;br&gt;这里，简单介绍下一个“跨库查询”的控件。&lt;br&gt;有的时候，我们一个脚本，可能只是临时性的，或者需要实时的去查一下，同步到数仓的话，可能不太方便，我们就可以使用跨库查询的控件&lt;br&gt;用到的表信息&lt;br&gt;&lt;img src=&quot;http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-10-01.png-blog.photo&quot; alt=&quot;Kettle-handbook-10-01.png&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-10-02.png-blog.photo&quot; alt=&quot;Kettle-handbook-10-02.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ETL-Kettle" scheme="http://yoursite.com/categories/ETL-Kettle/"/>
    
    
      <category term="Kettle" scheme="http://yoursite.com/tags/Kettle/"/>
    
  </entry>
  
  <entry>
    <title>Kettle手册（九）- 发送邮件</title>
    <link href="http://yoursite.com/2017/03/30/Kettle-handbook-09/"/>
    <id>http://yoursite.com/2017/03/30/Kettle-handbook-09/</id>
    <published>2017-03-30T03:24:44.000Z</published>
    <updated>2017-08-27T14:05:09.684Z</updated>
    
    <content type="html"><![CDATA[<p>在Kettle里面，我们每天执行完调度之后，想要监控下JOB的执行状态，通常我们可以会发送邮件，可以的话，还可以发送短信。</p>
<p>在Kettle里面，发送邮件很方便，这里，我们就简单的测试下。</p>
<h1 id="1-在作业中发送简单邮件"><a href="#1-在作业中发送简单邮件" class="headerlink" title="1. 在作业中发送简单邮件"></a>1. 在作业中发送简单邮件</h1><p>我们只需要使用到这个控件就可以了，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-01.png-blog.photo" alt="Kettle-handbook-09-01.png"><br>这样，一个简单的发送邮件流程就好了<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-02.png-blog.photo" alt="Kettle-handbook-09-02.png"></p>
<a id="more"></a>
<p>控件的配置：<br>收件人，抄送啊，信息，自行填写就行，多个收件人，使用“空格”分隔<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-03.png-blog.photo" alt="Kettle-handbook-09-03.png"><br>在服务器这里，我们填上服务器的信息就可以了<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-04.png-blog.photo" alt="Kettle-handbook-09-04.png"><br>这里是邮件消息的一些配置，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-05.png-blog.photo" alt="Kettle-handbook-09-05.png"><br>暂时先到这里，我们测试下结果<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-06.png-blog.photo" alt="Kettle-handbook-09-06.png"><br>然后，查看邮箱，我们会接收到这个邮件，刚刚简单测了下这个“回复名称”，就是<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-07.png-blog.photo" alt="Kettle-handbook-09-07.png"><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-08.png-blog.photo" alt="Kettle-handbook-09-08.png"><br>这里试过中文，会有问题，有乱码，可能是Windows下的原因，没有再去测试验证<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-09.png-blog.photo" alt="Kettle-handbook-09-09.png"><br>就是收到邮件时的一个发件人的名称，不同邮箱显示的不一样</p>
<h1 id="2-增加附件"><a href="#2-增加附件" class="headerlink" title="2. 增加附件"></a>2. 增加附件</h1><p>附件的话，也很简单，上面的面板中直接配置就可以了<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-10.png-blog.photo" alt="Kettle-handbook-09-10.png"><br>然后，我们需要将待发送的邮件，添加到结果集中<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-11.png-blog.photo" alt="Kettle-handbook-09-11.png"><br>在控件中，我们添加好文件就行了。<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-12.png-blog.photo" alt="Kettle-handbook-09-12.png"><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-13.png-blog.photo" alt="Kettle-handbook-09-13.png"><br>我们再次发送，验证下<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-14.png-blog.photo" alt="Kettle-handbook-09-14.png"><br>好了，附件也可以了，思路就是这样的，实际应用时，可能还有些问题得注意下</p>
<h1 id="3-自定义邮件内容"><a href="#3-自定义邮件内容" class="headerlink" title="3. 自定义邮件内容"></a>3. 自定义邮件内容</h1><p>到这里，我们会看到，邮件的正文内容，可能并不是我们想要的， 我们想要的可能是这样的信息<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-15.png-blog.photo" alt="Kettle-handbook-09-15.png"><br>这就需要自定义正文内容，我们需要勾选下面这个选项<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-16.png-blog.photo" alt="Kettle-handbook-09-16.png"><br>这里是可以使用变量的，我们可以拼接HTML来实现<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-17.png-blog.photo" alt="Kettle-handbook-09-17.png"><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-18.png-blog.photo" alt="Kettle-handbook-09-18.png"><br>好了，邮件的介绍，大概就这些，在转换中，也是可以使用的，大同小异</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Kettle里面，我们每天执行完调度之后，想要监控下JOB的执行状态，通常我们可以会发送邮件，可以的话，还可以发送短信。&lt;/p&gt;
&lt;p&gt;在Kettle里面，发送邮件很方便，这里，我们就简单的测试下。&lt;/p&gt;
&lt;h1 id=&quot;1-在作业中发送简单邮件&quot;&gt;&lt;a href=&quot;#1-在作业中发送简单邮件&quot; class=&quot;headerlink&quot; title=&quot;1. 在作业中发送简单邮件&quot;&gt;&lt;/a&gt;1. 在作业中发送简单邮件&lt;/h1&gt;&lt;p&gt;我们只需要使用到这个控件就可以了，&lt;br&gt;&lt;img src=&quot;http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-01.png-blog.photo&quot; alt=&quot;Kettle-handbook-09-01.png&quot;&gt;&lt;br&gt;这样，一个简单的发送邮件流程就好了&lt;br&gt;&lt;img src=&quot;http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-09-02.png-blog.photo&quot; alt=&quot;Kettle-handbook-09-02.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ETL-Kettle" scheme="http://yoursite.com/categories/ETL-Kettle/"/>
    
    
      <category term="Kettle" scheme="http://yoursite.com/tags/Kettle/"/>
    
  </entry>
  
  <entry>
    <title>Kettle手册（八）- 循环</title>
    <link href="http://yoursite.com/2017/03/29/Kettle-handbook-08/"/>
    <id>http://yoursite.com/2017/03/29/Kettle-handbook-08/</id>
    <published>2017-03-29T15:40:44.000Z</published>
    <updated>2017-08-27T13:47:04.004Z</updated>
    
    <content type="html"><![CDATA[<p>有的时候，我们想要在Kettle中实现这个循环的功能，比如，批量加载数据的时候，我们要对10张表执行同样的操作，只有表名和一些信息不一样，这时，写个循环就省事儿多了</p>
<h1 id="1-遍历结果集实现"><a href="#1-遍历结果集实现" class="headerlink" title="1. 遍历结果集实现"></a>1. 遍历结果集实现</h1><p><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-08-01.png-blog.photo" alt="Kettle-handbook-08-01.png"><br>这里的话，我们主要是通过一个将结果集返回，然后通过转换的设置来实现的</p>
<a id="more"></a>
<h2 id="1-1-query-the-result"><a href="#1-1-query-the-result" class="headerlink" title="1.1 query_the_result"></a>1.1 query_the_result</h2><p>这个转换，只要是将我们要遍历的结果集返回，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-08-02.png-blog.photo" alt="Kettle-handbook-08-02.png"><br>表输入，我们就是返回了5条记录，来做遍历<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-08-03.png-blog.photo" alt="Kettle-handbook-08-03.png"><br>复制记录到结果，这个控件的作用，就是我们可以在后面的转换继续使用这个结果集。</p>
<p>##1.2 traverse_the_result<br>这里呢，我们就是需要遍历的转换了，这里，我们只是获取结果集，然后将结果集输出<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-08-04.png-blog.photo" alt="Kettle-handbook-08-04.png"><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-08-05.png-blog.photo" alt="Kettle-handbook-08-05.png"><br>还有一个很重要的一步，怎样让这个转换可以根据结果集的条数，去循环执行呢？<br>就是这个“执行每一个输入行”<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-08-06.png-blog.photo" alt="Kettle-handbook-08-06.png"><br>我们执行下看看<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-08-07.png-blog.photo" alt="Kettle-handbook-08-07.png"></p>
<h1 id="2-使用JS实现"><a href="#2-使用JS实现" class="headerlink" title="2. 使用JS实现"></a>2. 使用JS实现</h1><p>网上有很多的例子，介绍怎样用JS来控制循环，这里我们也简单的测试下<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-08-08.png-blog.photo" alt="Kettle-handbook-08-08.png"></p>
<h2 id="2-1-query-the-result"><a href="#2-1-query-the-result" class="headerlink" title="2.1 query_the_result"></a>2.1 query_the_result</h2><p>这一步，和上面的一样，就是将结果集返回<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-08-09.png-blog.photo" alt="Kettle-handbook-08-09.png"></p>
<h2 id="2-2-travers-the-result"><a href="#2-2-travers-the-result" class="headerlink" title="2.2 travers_the_result"></a>2.2 travers_the_result</h2><p>这里主要是使用JS将结果集进行遍历，通过JS，将一些结果存放到变量里面，在后面的操作中就可以使用了，通过${xxx}的方式使用<br>这个其实和Java、JS里面循环思路一样，通过结果集的总数“total_num”和下标“LoopCounter”进行判断<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-08-10.png-blog.photo" alt="Kettle-handbook-08-10.png"></p>
<h2 id="2-3-evaluate-the-loop-count"><a href="#2-3-evaluate-the-loop-count" class="headerlink" title="2.3 evaluate_the_loop_count"></a>2.3 evaluate_the_loop_count</h2><p>这一步，就是判断下标的值和结果集的总数，进行对比，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-08-11.png-blog.photo" alt="Kettle-handbook-08-11.png"></p>
<h2 id="2-4-print-the-log"><a href="#2-4-print-the-log" class="headerlink" title="2.4 print_the_log"></a>2.4 print_the_log</h2><p>输出下，我们想要使用的变量<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-08-12.png-blog.photo" alt="Kettle-handbook-08-12.png"></p>
<h2 id="2-5-manage-the-loop-index"><a href="#2-5-manage-the-loop-index" class="headerlink" title="2.5 manage_the_loop_index"></a>2.5 manage_the_loop_index</h2><p>这一步，给下标加一，然后获取下一条记录<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-08-13.png-blog.photo" alt="Kettle-handbook-08-13.png"><br>好了，执行下，我们看看<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-08-14.png-blog.photo" alt="Kettle-handbook-08-14.png"><br>好了，循环的使用先介绍到这里</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有的时候，我们想要在Kettle中实现这个循环的功能，比如，批量加载数据的时候，我们要对10张表执行同样的操作，只有表名和一些信息不一样，这时，写个循环就省事儿多了&lt;/p&gt;
&lt;h1 id=&quot;1-遍历结果集实现&quot;&gt;&lt;a href=&quot;#1-遍历结果集实现&quot; class=&quot;headerlink&quot; title=&quot;1. 遍历结果集实现&quot;&gt;&lt;/a&gt;1. 遍历结果集实现&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-08-01.png-blog.photo&quot; alt=&quot;Kettle-handbook-08-01.png&quot;&gt;&lt;br&gt;这里的话，我们主要是通过一个将结果集返回，然后通过转换的设置来实现的&lt;/p&gt;
    
    </summary>
    
      <category term="ETL-Kettle" scheme="http://yoursite.com/categories/ETL-Kettle/"/>
    
    
      <category term="Kettle" scheme="http://yoursite.com/tags/Kettle/"/>
    
  </entry>
  
  <entry>
    <title>Kettle手册（七）- 资源库的使用</title>
    <link href="http://yoursite.com/2017/03/29/Kettle-handbook-07/"/>
    <id>http://yoursite.com/2017/03/29/Kettle-handbook-07/</id>
    <published>2017-03-29T15:24:44.000Z</published>
    <updated>2017-08-27T13:28:47.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么使用资源库"><a href="#1-为什么使用资源库" class="headerlink" title="1. 为什么使用资源库"></a>1. 为什么使用资源库</h1><p>之前，我们新建转换或者作业的时候，都是直接保存在本地，而如果我们是多人开发的话，除了使用SVN等版本控制软件，还可以使用Kettle的资源库，他会将转换、作业直接保存在数据库中，而且，连接资源库的话，我们就不需要每一次都新建数据库连接了，用起来还是蛮方便的。</p>
<h1 id="2-新建资源库"><a href="#2-新建资源库" class="headerlink" title="2. 新建资源库"></a>2. 新建资源库</h1><p>Kettle7.0里面，是在右上角这个Connect来连接的<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-07-01.png-blog.photo" alt="Kettle-handbook-07-01.png"></p>
<a id="more"></a>
<h2 id="2-1-资源库的类型"><a href="#2-1-资源库的类型" class="headerlink" title="2.1 资源库的类型"></a>2.1 资源库的类型</h2><p>资源库有3中类型<br>Pentaho Repository<br>Database Repository（使用数据库存储）<br>File Repository（使用文件存储）<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-07-02.png-blog.photo" alt="Kettle-handbook-07-02.png"><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-07-03.png-blog.photo" alt="Kettle-handbook-07-03.png"></p>
<h2 id="2-2-新建Pentaho-Repository"><a href="#2-2-新建Pentaho-Repository" class="headerlink" title="2.2 新建Pentaho Repository"></a>2.2 新建Pentaho Repository</h2><p>我们单击上面的get started 之后，就会进入新建界面<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-07-04.png-blog.photo" alt="Kettle-handbook-07-04.png"><br><a href="http://localhost:8080/pentaho" target="_blank" rel="external">http://localhost:8080/pentaho</a><br>一开始还没搞懂这个Server到底怎么启动，后来google了半天发现<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-07-05.png-blog.photo" alt="Kettle-handbook-07-05.png"><br>后来又找到了这个，应该是要安装其他的组件才行，这个类型的库就放弃吧。。<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-07-06.png-blog.photo" alt="Kettle-handbook-07-06.png"></p>
<h2 id="2-3-Database-Repository"><a href="#2-3-Database-Repository" class="headerlink" title="2.3 Database Repository"></a>2.3 Database Repository</h2><p>好了，这回，我们选择哪个database的资源库<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-07-07.png-blog.photo" alt="Kettle-handbook-07-07.png"><br>我们填一个connection的名字，然后配置一个资源库的连接就可以了，最好给kettle新建一个数据库使用<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-07-08.png-blog.photo" alt="Kettle-handbook-07-08.png"><br>至于数据库连接的话，和转换里面是一样的，大家可以自行新建一个<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-07-09.png-blog.photo" alt="Kettle-handbook-07-09.png"><br>配置好，以后，大家选择Finish就可以了，然后，我们可以连接下这个库，注意下，这里的用户名和密码，<br>默认是admin/admin，大家直接登录就好了，这是Kettle自己初始化的<br>这个怎么改呢，暂时还没有发现，待研究，等我再google看看，估计官网上会有。<br>（找了下，发现了在哪改密码，就是刚刚的搜索资源库<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-07-10.png-blog.photo" alt="Kettle-handbook-07-10.png"><br>)<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-07-11.png-blog.photo" alt="Kettle-handbook-07-11.png"><br>连接后，我们正常使用就好了，没啥两样，会多一些功能，比如，探索资源库这里<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-07-12.png-blog.photo" alt="Kettle-handbook-07-12.png"><br>我们再保存作业和转换的话，会直接保存在数据库中，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-07-13.png-blog.photo" alt="Kettle-handbook-07-13.png"><br>而且，很好的一个功能，个人感觉，就是数据库连接只需要创建一次，在哪里都可以用了，不需要再次创建。</p>
<h2 id="2-4-File-Repository"><a href="#2-4-File-Repository" class="headerlink" title="2.4 File Repository"></a>2.4 File Repository</h2><p>这个和database的资源库，就差不多了，只不过是基于文件的，保存在本地就可以了<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-07-14.png-blog.photo" alt="Kettle-handbook-07-14.png"><br>这个就和Eclipse一个工作区差不多，转换、作业都保存在这个目录下<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-07-15.png-blog.photo" alt="Kettle-handbook-07-15.png"><br>好了，关于资源库，就简单的说这些了，大家可以自行连接，试试。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-为什么使用资源库&quot;&gt;&lt;a href=&quot;#1-为什么使用资源库&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么使用资源库&quot;&gt;&lt;/a&gt;1. 为什么使用资源库&lt;/h1&gt;&lt;p&gt;之前，我们新建转换或者作业的时候，都是直接保存在本地，而如果我们是多人开发的话，除了使用SVN等版本控制软件，还可以使用Kettle的资源库，他会将转换、作业直接保存在数据库中，而且，连接资源库的话，我们就不需要每一次都新建数据库连接了，用起来还是蛮方便的。&lt;/p&gt;
&lt;h1 id=&quot;2-新建资源库&quot;&gt;&lt;a href=&quot;#2-新建资源库&quot; class=&quot;headerlink&quot; title=&quot;2. 新建资源库&quot;&gt;&lt;/a&gt;2. 新建资源库&lt;/h1&gt;&lt;p&gt;Kettle7.0里面，是在右上角这个Connect来连接的&lt;br&gt;&lt;img src=&quot;http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-07-01.png-blog.photo&quot; alt=&quot;Kettle-handbook-07-01.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ETL-Kettle" scheme="http://yoursite.com/categories/ETL-Kettle/"/>
    
    
      <category term="Kettle" scheme="http://yoursite.com/tags/Kettle/"/>
    
  </entry>
  
  <entry>
    <title>Kettle手册（六）- Hop小记</title>
    <link href="http://yoursite.com/2017/03/29/Kettle-handbook-06/"/>
    <id>http://yoursite.com/2017/03/29/Kettle-handbook-06/</id>
    <published>2017-03-29T14:24:44.000Z</published>
    <updated>2017-08-27T13:10:27.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Hop"><a href="#1-什么是Hop" class="headerlink" title="1. 什么是Hop"></a>1. 什么是Hop</h1><p>在我们前面，使用Kettle过程中，控件与控件之间的连线，这里，我们详细介绍下它，它在Kettle中叫Hop（跳）。<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-01.png-blog.photo" alt="Kettle-handbook-06-01.png"><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-02.png-blog.photo" alt="Kettle-handbook-06-02.png"></p>
<a id="more"></a>
<h1 id="2-Hop的发送方式（转换）"><a href="#2-Hop的发送方式（转换）" class="headerlink" title="2. Hop的发送方式（转换）"></a>2. Hop的发送方式（转换）</h1><p>在转换中，一般情况，控件和控件之间只有一个Hop，当然，如果需要的话，我们拖了2个控件出来，像这样：<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-03.png-blog.photo" alt="Kettle-handbook-06-03.png"><br>Kettle会提示你，下面的信息，让你选择，数据发送的方式<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-04.png-blog.photo" alt="Kettle-handbook-06-04.png"></p>
<h2 id="2-1-分发记录"><a href="#2-1-分发记录" class="headerlink" title="2.1 分发记录"></a>2.1 分发记录</h2><p>目标步骤轮流接收记录，其实就是你一条，我一条，轮着接收数据，这个我们试一下就知道了，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-05.png-blog.photo" alt="Kettle-handbook-06-05.png"><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-06.png-blog.photo" alt="Kettle-handbook-06-06.png"><br>我们执行下，看看这个结果试试，我们再步骤度量中，可以看到，a.txt和b.txt分别写入的数量<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-07.png-blog.photo" alt="Kettle-handbook-06-07.png"><br>看看结果文件，就是这样的<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-08.png-blog.photo" alt="Kettle-handbook-06-08.png"></p>
<h2 id="2-2-复制记录"><a href="#2-2-复制记录" class="headerlink" title="2.2 复制记录"></a>2.2 复制记录</h2><p>所有记录同时发送到所有的目标步骤，这个看起来就简单多了，比如上面的例子，2个文本文件会接收到同样的所有的数据，我们也试一下<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-09.png-blog.photo" alt="Kettle-handbook-06-09.png"><br>结果文件的话，就是2个节点，接收到的数据都是一样的<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-10.png-blog.photo" alt="Kettle-handbook-06-10.png"></p>
<h1 id="3-Hop的状态（作业）"><a href="#3-Hop的状态（作业）" class="headerlink" title="3.Hop的状态（作业）"></a>3.Hop的状态（作业）</h1><p>在作业中，Hop主要用来控制流程<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-11.png-blog.photo" alt="Kettle-handbook-06-11.png"><br>有3种状态，一个锁，一个绿色的对号，一个红色的叉号<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-12.png-blog.photo" alt="Kettle-handbook-06-12.png"><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-13.png-blog.photo" alt="Kettle-handbook-06-13.png"><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-14.png-blog.photo" alt="Kettle-handbook-06-14.png"><br>简单来说，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-15.png-blog.photo" alt="Kettle-handbook-06-15.png">：表示无论上一步执行成功还是失败，都一定会执行下一步<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-16.png-blog.photo" alt="Kettle-handbook-06-16.png">：表示上一步执行成功才会执行下一步<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-17.png-blog.photo" alt="Kettle-handbook-06-17.png">：表示上一步执行失败执行下一步<br>比如我们上面的例子，我们的转换执行成功后，就结束了，如果转换执行失败了，我们就发送邮件。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-什么是Hop&quot;&gt;&lt;a href=&quot;#1-什么是Hop&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是Hop&quot;&gt;&lt;/a&gt;1. 什么是Hop&lt;/h1&gt;&lt;p&gt;在我们前面，使用Kettle过程中，控件与控件之间的连线，这里，我们详细介绍下它，它在Kettle中叫Hop（跳）。&lt;br&gt;&lt;img src=&quot;http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-01.png-blog.photo&quot; alt=&quot;Kettle-handbook-06-01.png&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-06-02.png-blog.photo&quot; alt=&quot;Kettle-handbook-06-02.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ETL-Kettle" scheme="http://yoursite.com/categories/ETL-Kettle/"/>
    
    
      <category term="Kettle" scheme="http://yoursite.com/tags/Kettle/"/>
    
  </entry>
  
  <entry>
    <title>Kettle手册（五）- 实例-增量同步数据</title>
    <link href="http://yoursite.com/2017/03/28/Kettle-handbook-05/"/>
    <id>http://yoursite.com/2017/03/28/Kettle-handbook-05/</id>
    <published>2017-03-28T15:30:44.000Z</published>
    <updated>2017-08-27T13:11:40.355Z</updated>
    
    <content type="html"><![CDATA[<p>综合前面的几个例子，我们这里来是实现下增量数据的同步。<br>这里只是分享一种方法，实际工作中，还会有其他更好的方案。<br>增量同步的整体思路一般就是：首先拿到这张表的增量数据，怎么拿增量呢，源表需要有一个时间字段，代表该条记录的最新更新时间（及只要该条记录变化，该时间字段就会更新），当然有时间字段最好了，没有的话，可能需要做全表对比之类的操作；正常情况下，业务系统的表中都是有主键的，我们拿到增量数据之后，需要判断该记录的新插入的，还是更新的记录，如果是更新记录，我们需要先将数据加载到中间表，然后，根据主键将目标表中已存在的数据删除，最后再将本次的增量数据插入到目标表。</p>
<h2 id="1-配置表的设计（元数据表）"><a href="#1-配置表的设计（元数据表）" class="headerlink" title="1.配置表的设计（元数据表）"></a>1.配置表的设计（元数据表）</h2><p>首先我们需要一张配置表，来保存我们要增量同步的表的基本信息<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--元数据表</span></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> tm_etl_table(</div><div class="line">	table_name <span class="built_in">varchar</span>(<span class="number">50</span>), <span class="comment">--表名</span></div><div class="line">	is_run <span class="built_in">int</span> , <span class="comment">--调度状态</span></div><div class="line">	update_time <span class="keyword">timestamp</span>,<span class="comment">--表数据更新时间</span></div><div class="line">	etl_insert_time <span class="keyword">timestamp</span> <span class="comment">--记录更新时间</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>我们初始化一条记录，我们就以这张ods_tm_book表<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-05-01.png-blog.photo" alt="Kettle-handbook-05-01.png"><br>一些基础表准备</p>
<a id="more"></a>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 源表</span></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> tm_book(<span class="keyword">id</span> <span class="built_in">int</span>,book_name <span class="built_in">varchar</span>(<span class="number">10</span>),latest_time <span class="keyword">timestamp</span>);</div><div class="line"></div><div class="line"><span class="comment">-- 源表数据初始化</span></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tm_book(<span class="keyword">id</span>,book_name,latest_time)</div><div class="line"><span class="keyword">select</span> x,x||<span class="string">'_name'</span>,clock_timestamp() <span class="keyword">from</span> generate_series(<span class="number">1</span>,<span class="number">10</span>) x;</div><div class="line"></div><div class="line"><span class="comment">-- 目标表和中间表</span></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> ods_tm_book(<span class="keyword">id</span> <span class="built_in">int</span>,book_name <span class="built_in">varchar</span>(<span class="number">10</span>),latest_time <span class="keyword">timestamp</span>,etl_insert_time <span class="keyword">timestamp</span>);</div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> staging_tm_book(<span class="keyword">id</span> <span class="built_in">int</span>,book_name <span class="built_in">varchar</span>(<span class="number">10</span>),latest_time <span class="keyword">timestamp</span>);</div></pre></td></tr></table></figure>
<p>源表中的数据<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-05-02.png-blog.photo" alt="Kettle-handbook-05-02.png"></p>
<h2 id="2-同步数据的流程开发"><a href="#2-同步数据的流程开发" class="headerlink" title="2.同步数据的流程开发"></a>2.同步数据的流程开发</h2><p>整体流程是这样的，注意下，这个只是为了简单演示了这个增量的例子，实际应用的话得修改，这是有漏洞的。<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-05-03.png-blog.photo" alt="Kettle-handbook-05-03.png"></p>
<h3 id="2-1更新元数据表的状态并获取表更新时间"><a href="#2-1更新元数据表的状态并获取表更新时间" class="headerlink" title="2.1更新元数据表的状态并获取表更新时间"></a>2.1更新元数据表的状态并获取表更新时间</h3><p>就是我们第一个状态，我们更新tm_etl_table表，更新is_run=0，表示我们开始同步数据了，update_time，初始化为 ‘1970-01-01’，表示我们要拉取所有的数据<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-05-04.png-blog.photo" alt="Kettle-handbook-05-04.png"><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-05-05.png-blog.photo" alt="Kettle-handbook-05-05.png"><br>这里，我们将该表的更新时间作为变量，我们会在后面的转换中使用<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-05-06.png-blog.photo" alt="Kettle-handbook-05-06.png"></p>
<h3 id="2-2-加载数据到中间表"><a href="#2-2-加载数据到中间表" class="headerlink" title="2.2 加载数据到中间表"></a>2.2 加载数据到中间表</h3><p>我们这里，直接表对表，将数据插入到staging<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-05-07.png-blog.photo" alt="Kettle-handbook-05-07.png"><br>其中，表输入中，我们需要根据前面的更新时间变量，获取增量数据，注意，需要勾选上“替换SQL语句中的变量”<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-05-08.png-blog.photo" alt="Kettle-handbook-05-08.png"><br>这里，我们直接就表输出到中间表，每次都需将清空表数据<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-05-09.png-blog.photo" alt="Kettle-handbook-05-09.png"></p>
<h3 id="2-3-加载数据到目标表"><a href="#2-3-加载数据到目标表" class="headerlink" title="2.3 加载数据到目标表"></a>2.3 加载数据到目标表</h3><p><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-05-10.png-blog.photo" alt="Kettle-handbook-05-10.png"><br>这里，主要有3段脚本（为了方便，就这样吧），根据主键ID，清空目标表数据，然后，将数据插入到目标表，最后，更新tm_etl_table表中的记录状态<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-05-11.png-blog.photo" alt="Kettle-handbook-05-11.png"><br>好了，用Kettle实现一个增量的逻辑大概就是这样了，</p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>这里整理几个问题</p>
<h3 id="3-1-中间表"><a href="#3-1-中间表" class="headerlink" title="3.1 中间表"></a>3.1 中间表</h3><p>这里的话，使用了中间表，Kettle中是有一个控件的，应该叫那个“插入/更新”，可以根据主键将数据更新掉，这个控件之前使用时，发现很慢，就一直没用，后面的话，可能会写个例子，简单测试看看。使用中间表，缓存下数据，也是不错的方法。</p>
<h3 id="3-2-增量流程"><a href="#3-2-增量流程" class="headerlink" title="3.2 增量流程"></a>3.2 增量流程</h3><p>目前公司中，增量抽取，是这样的，首先各个业务系统的数据导出到文本文件，然后批量将文件加载到数据仓库中（这里使用循环加载的）。因为每天的数据量比较大，如果知己到表的话，会很慢，使用文件，一些数据库都有批量加载的命令，很快很方便，比如：PostgreSQL中的copy命令，Greenplum中的外部表，还有Mysql中的load data等等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;综合前面的几个例子，我们这里来是实现下增量数据的同步。&lt;br&gt;这里只是分享一种方法，实际工作中，还会有其他更好的方案。&lt;br&gt;增量同步的整体思路一般就是：首先拿到这张表的增量数据，怎么拿增量呢，源表需要有一个时间字段，代表该条记录的最新更新时间（及只要该条记录变化，该时间字段就会更新），当然有时间字段最好了，没有的话，可能需要做全表对比之类的操作；正常情况下，业务系统的表中都是有主键的，我们拿到增量数据之后，需要判断该记录的新插入的，还是更新的记录，如果是更新记录，我们需要先将数据加载到中间表，然后，根据主键将目标表中已存在的数据删除，最后再将本次的增量数据插入到目标表。&lt;/p&gt;
&lt;h2 id=&quot;1-配置表的设计（元数据表）&quot;&gt;&lt;a href=&quot;#1-配置表的设计（元数据表）&quot; class=&quot;headerlink&quot; title=&quot;1.配置表的设计（元数据表）&quot;&gt;&lt;/a&gt;1.配置表的设计（元数据表）&lt;/h2&gt;&lt;p&gt;首先我们需要一张配置表，来保存我们要增量同步的表的基本信息&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;--元数据表&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; tm_etl_table(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	table_name &lt;span class=&quot;built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;), &lt;span class=&quot;comment&quot;&gt;--表名&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	is_run &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; , &lt;span class=&quot;comment&quot;&gt;--调度状态&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	update_time &lt;span class=&quot;keyword&quot;&gt;timestamp&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;--表数据更新时间&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	etl_insert_time &lt;span class=&quot;keyword&quot;&gt;timestamp&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;--记录更新时间&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们初始化一条记录，我们就以这张ods_tm_book表&lt;br&gt;&lt;img src=&quot;http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-05-01.png-blog.photo&quot; alt=&quot;Kettle-handbook-05-01.png&quot;&gt;&lt;br&gt;一些基础表准备&lt;/p&gt;
    
    </summary>
    
      <category term="ETL-Kettle" scheme="http://yoursite.com/categories/ETL-Kettle/"/>
    
    
      <category term="Kettle" scheme="http://yoursite.com/tags/Kettle/"/>
    
  </entry>
  
  <entry>
    <title>Kettle手册（四）- 变量的使用</title>
    <link href="http://yoursite.com/2017/03/28/Kettle-handbook-04/"/>
    <id>http://yoursite.com/2017/03/28/Kettle-handbook-04/</id>
    <published>2017-03-28T15:24:44.000Z</published>
    <updated>2017-08-26T16:01:57.685Z</updated>
    
    <content type="html"><![CDATA[<p>我们在这一回，介绍下，Kettle中全局变量的使用，我们前面说过的配置文件，其实就是配置全局变量的地方<br><a href="2017/03/27/Kettle-handbook-03/">Kettle手册（三）- 配置文件的使用及密码加密 </a></p>
<div class="note primary"><h2 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1. 全局变量"></a>1. 全局变量</h2></div>
<p>就是我们上面说的kettle.properties文件，我们在里面定义的变量，我们可以在所有的转换或者作业中获得到，比如，我们前面，说的数据库参数<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-04-01.png-blog.photo" alt="Kettle-handbook-04-01.png"><br>之前，我们已经在数据库连接中测试过，是可以，这里，我们输出下这个变量，看看</p>
<a id="more"></a>
<h3 id="1-1-输出变量的值"><a href="#1-1-输出变量的值" class="headerlink" title="1.1 输出变量的值"></a>1.1 输出变量的值</h3><p>我们这里，用到了“获取变量”这个控件<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-04-02.png-blog.photo" alt="Kettle-handbook-04-02.png"><br>我们单击，”Get Variables”,就可以获取到当前的全局变量信息<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-04-03.png-blog.photo" alt="Kettle-handbook-04-03.png"><br>我们选择几个输出试试<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-04-04.png-blog.photo" alt="Kettle-handbook-04-04.png"><br>还有一个，”日志“控件，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-04-05.png-blog.photo" alt="Kettle-handbook-04-05.png"><br>拖好之后，我们直接执行，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-04-06.png-blog.photo" alt="Kettle-handbook-04-06.png"><br>日志中，我们会看到，我们定义在文件中的参数（加密的参数，我没有重启，所以显示的还是原来的）<br>那我们，可不可以，动态的增加变量呢？</p>
<h3 id="1-2-动态增加变量"><a href="#1-2-动态增加变量" class="headerlink" title="1.2 动态增加变量"></a>1.2 动态增加变量</h3><p>刚刚也在网上找了些资料，尝试了下，这里简单分享下（貌似，这得算是对局部变量的操作，暂时就放在这里吧）<br>我们先试下在转换中设置变量，作业中也是可以使用的，我们后面再说<br>测试流程是这样的， 我们再表输入中，有2个时间参数，然后作为变量<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-04-07.png-blog.photo" alt="Kettle-handbook-04-07.png"><br>比如，有这样一个场景，我们每天需要定时调度一些SP，SP都有开始时间，结束时间，调用时，需要传参数进去，<br>这个时候，我们在使用Kettle的时候，就可以通过这样的方式，去设置变量，然后再调用SP<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-04-08.png-blog.photo" alt="Kettle-handbook-04-08.png"><br>我们单击获取字段后，就可以了，这里可以修改变量存在的范围<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-04-09.png-blog.photo" alt="Kettle-handbook-04-09.png"><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-04-10.png-blog.photo" alt="Kettle-handbook-04-10.png"><br>执行后，输出，后面，我们就可以使用这2个时间变量了<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-04-11.png-blog.photo" alt="Kettle-handbook-04-11.png"><br>这里使用的时候，也遇到一个问题，就是变量的默认值，一直都没有生效，不知道为什么，不管是，静态值，还是变量值，都没有办法，待研究。</p>
<div class="note primary"><h2 id="2-局部变量（命名参数）"><a href="#2-局部变量（命名参数）" class="headerlink" title="2. 局部变量（命名参数）"></a>2. 局部变量（命名参数）</h2></div>
<p>在kettle中，相对于全局变量，我们还可以使用局部变量。感觉，这个全局变量，局部变量，都是相对而言的，<br>就网上大部分资料来说，Kettle中的局部变量就是“命名参数”<br>我们再转换中，右键单击，选择，转换设置</p>
<p><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-04-12.png-blog.photo" alt="Kettle-handbook-04-12.png"><br>我们选择，“命名参数”，定义一个变量，我们给一个默认值<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-04-13.png-blog.photo" alt="Kettle-handbook-04-13.png"><br>然后，在日志中，将变量输出<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-04-14.png-blog.photo" alt="Kettle-handbook-04-14.png"><br>我们执行下，这个转换，运行时的界面，我们可以看到，这个参数是可以动态改变的，或者，我们再命令行调这个转换的时候，同样可以给他赋值<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-04-15.png-blog.photo" alt="Kettle-handbook-04-15.png"><br>运行结果，这个就是简单的局部变量了<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-04-16.png-blog.photo" alt="Kettle-handbook-04-16.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在这一回，介绍下，Kettle中全局变量的使用，我们前面说过的配置文件，其实就是配置全局变量的地方&lt;br&gt;&lt;a href=&quot;2017/03/27/Kettle-handbook-03/&quot;&gt;Kettle手册（三）- 配置文件的使用及密码加密 &lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;h2 id=&quot;1-全局变量&quot;&gt;&lt;a href=&quot;#1-全局变量&quot; class=&quot;headerlink&quot; title=&quot;1. 全局变量&quot;&gt;&lt;/a&gt;1. 全局变量&lt;/h2&gt;&lt;/div&gt;
&lt;p&gt;就是我们上面说的kettle.properties文件，我们在里面定义的变量，我们可以在所有的转换或者作业中获得到，比如，我们前面，说的数据库参数&lt;br&gt;&lt;img src=&quot;http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-04-01.png-blog.photo&quot; alt=&quot;Kettle-handbook-04-01.png&quot;&gt;&lt;br&gt;之前，我们已经在数据库连接中测试过，是可以，这里，我们输出下这个变量，看看&lt;/p&gt;
    
    </summary>
    
      <category term="ETL-Kettle" scheme="http://yoursite.com/categories/ETL-Kettle/"/>
    
    
      <category term="Kettle" scheme="http://yoursite.com/tags/Kettle/"/>
    
  </entry>
  
  <entry>
    <title>Kettle手册（三）- 配置文件的使用及密码加密</title>
    <link href="http://yoursite.com/2017/03/28/Kettle-handbook-03/"/>
    <id>http://yoursite.com/2017/03/28/Kettle-handbook-03/</id>
    <published>2017-03-28T14:24:44.000Z</published>
    <updated>2017-08-26T15:39:56.222Z</updated>
    
    <content type="html"><![CDATA[<p>好了，我们上一回，练习了一个从数据库导出数据到Excel的例子，我们想一下，如果有很多个转换，我们没链接一次数据库，是不是都需要重复的输入那些数据库地址啊，数据库啊，用户名啊之类的。其实是不用的，我们可以使用变量的方式，写在配置文件中，下面，我们来看看。而且，我们平时开发，都有开发环境、UAT环境、生产环境，连接的地址都不一样，也不可能手动的去修改。</p>
<div class="note primary"><h2 id="1-Kettle的配置文件"><a href="#1-Kettle的配置文件" class="headerlink" title="1. Kettle的配置文件"></a>1. Kettle的配置文件</h2></div>
<p>配置文件在哪呢？Windows下，是再当前用户的目录下，一般再C盘，Users下面，有一个当前用户的文件夹，下面有.kettle文件夹<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-03-01.png-blog.photo" alt="Kettle-handbook-03-01.png"><br>进入之后，我们会看到一个kettle.properties的文件，我们的数据库配置信息，就可以放在这里，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-03-02.png-blog.photo" alt="Kettle-handbook-03-02.png"></p>
<a id="more"></a>
<p>我们打开之后，编辑一下<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-03-03.png-blog.photo" alt="Kettle-handbook-03-03.png"><br>保存后，我们要重新启动下Kettle，因为这个配置文件是启动时加载的<br>重启后，我们将上一次，配置的转换打开，使用变量替换下之前的配置，Kettle中，我们使用${xxx}，表示引用一个变量，执行时，会自动替换<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-03-07.png-blog.photo" alt="Kettle-handbook-03-07.png"><br>我们测试下，同样时可以成功的。<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-03-08.png-blog.photo" alt="Kettle-handbook-03-08.png"><br>好了，这样，以后，不管是，数据库地址变化，还是部署生产，我们只需要修改配置文件就可以了。</p>
<div class="note primary"><h2 id="2-密码加密"><a href="#2-密码加密" class="headerlink" title="2. 密码加密"></a>2. 密码加密</h2></div>
<p>这里，顺便说下，加密的问题，比如，我们上面的数据库密码，是明文的，这样是不太安全的，而实际上，我们都是需要对密码进行加密的<br>我们进到Kettle的安装目录<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-03-04.png-blog.photo" alt="Kettle-handbook-03-04.png"><br>我们会看到，这里有一个Encr.bat，这就是可以加密的脚本<br>使用方法<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-03-06.png-blog.photo" alt="Kettle-handbook-03-06.png"><br>我们输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Encr.bat -kettle postgres</div></pre></td></tr></table></figure></p>
<p>执行后，会生成，这样一个加密后的密码，然后，我们可以使用这个加密后的字符串，替换我们的密码<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-03-05.png-blog.photo" alt="Kettle-handbook-03-05.png"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pg_password = Encrypted 2be98afc86aa7f2e4cb79ff228dc6fa8c</div></pre></td></tr></table></figure></p>
<p>大家可以试下，这样也是可以的，好了，这个例子就到这。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好了，我们上一回，练习了一个从数据库导出数据到Excel的例子，我们想一下，如果有很多个转换，我们没链接一次数据库，是不是都需要重复的输入那些数据库地址啊，数据库啊，用户名啊之类的。其实是不用的，我们可以使用变量的方式，写在配置文件中，下面，我们来看看。而且，我们平时开发，都有开发环境、UAT环境、生产环境，连接的地址都不一样，也不可能手动的去修改。&lt;/p&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;h2 id=&quot;1-Kettle的配置文件&quot;&gt;&lt;a href=&quot;#1-Kettle的配置文件&quot; class=&quot;headerlink&quot; title=&quot;1. Kettle的配置文件&quot;&gt;&lt;/a&gt;1. Kettle的配置文件&lt;/h2&gt;&lt;/div&gt;
&lt;p&gt;配置文件在哪呢？Windows下，是再当前用户的目录下，一般再C盘，Users下面，有一个当前用户的文件夹，下面有.kettle文件夹&lt;br&gt;&lt;img src=&quot;http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-03-01.png-blog.photo&quot; alt=&quot;Kettle-handbook-03-01.png&quot;&gt;&lt;br&gt;进入之后，我们会看到一个kettle.properties的文件，我们的数据库配置信息，就可以放在这里，&lt;br&gt;&lt;img src=&quot;http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-03-02.png-blog.photo&quot; alt=&quot;Kettle-handbook-03-02.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ETL-Kettle" scheme="http://yoursite.com/categories/ETL-Kettle/"/>
    
    
      <category term="Kettle" scheme="http://yoursite.com/tags/Kettle/"/>
    
  </entry>
  
  <entry>
    <title>Kettle手册（二）- 将数据导出为Excel</title>
    <link href="http://yoursite.com/2017/03/27/Kettle-handbook-02/"/>
    <id>http://yoursite.com/2017/03/27/Kettle-handbook-02/</id>
    <published>2017-03-27T15:24:44.000Z</published>
    <updated>2017-08-26T16:02:23.400Z</updated>
    
    <content type="html"><![CDATA[<p>好了，我们先来看第一个例子，就是怎样将数据库中的数据，导出为Excel。<br>平时，如果我们需要将数据导出Excel的话，我们可能会直接复制，然后粘贴出来，但是数据量大的话，就不好用了；<br>或者使用Java等开发语言，写代码，导出Excel；或者一些数据库连接工具自带的导出功能。<br>其实，我们用Kettle的话，还是很方便的，但是平时用下来，Kettle的这个功能还是有些缺陷的，比如导出Excel2007+的时候，经常会报错，我一直也没有解决，这次记录博客顺便研究看看。</p>
<div class="note primary"><h1 id="1-Kettle的下载及使用"><a href="#1-Kettle的下载及使用" class="headerlink" title="1. Kettle的下载及使用"></a>1. Kettle的下载及使用</h1></div>
<p>正式开始之前，我们简单说下Kettle的安装配置啥的，Kettle是绿色的，下载之后，直接运行就可以了<br>刚刚在网上下了个最新版的，后面，我们就是用这个7.0版本介绍官网地址：<a href="http://community.pentaho.com/projects/data-integration/" target="_blank" rel="external">Kettle官网</a></p>
<p><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-01.png-blog.photo" alt="Kettle-handbook-02-01.png"></p>
<a id="more"></a>
<p>他这个网站，应该是不太好访问，有VPN的话，可以用起来，下载的话，大概800M左右，后面看看上传一份，昨天为了下载，现冲了个蓝灯的会员<br>解压以后，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-02.png-blog.photo" alt="Kettle-handbook-02-02.png"><br>目录大概是这样的，我们会看到，这里有.bat文件和.sh文件，.bat就是我们在windows下使用的，.sh就是在Linux下使用的，我们找到 Spoon.bat这个文件，就可以启动Kettle了，奥，对了，得先安装下Java<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-03.png-blog.photo" alt="Kettle-handbook-02-03.png"><br>打开后，就是这样了，都是图形界面的，很好用<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-04.png-blog.photo" alt="Kettle-handbook-02-04.png"><br>Kettle中，主要有2中任务，一个是作业，一个是转换。一般来说，转换是一系列具体的操作，比如：调度SP，导出Excel等等；作业的话，就是按照一定流程来调度一系列转换。大概是这样，实际上，他们也是可以嵌套调用的，我们后面可以再讨论。</p>
<div class="note primary"><h1 id="2-第一个转换-将数据导出为Excel"><a href="#2-第一个转换-将数据导出为Excel" class="headerlink" title="2. 第一个转换-将数据导出为Excel"></a>2. 第一个转换-将数据导出为Excel</h1></div>
<p>为了实现这个功能，我们需要：</p>
<ol>
<li>连接到数据库</li>
<li>导出为Excel</li>
</ol>
<p>首先，我们新建一个转换，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-05.png-blog.photo" alt="Kettle-handbook-02-05.png"><br>新建，之后，我们可以看到，工具箱中，有很多的控件，我们都可以使用，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-06.png-blog.photo" alt="Kettle-handbook-02-06.png"><br>很多我也没有用过，大家可以自行去尝试使用<br>好了，下面，我们就开始介绍我们这次的主题，导出数据到Excel<br>既然，是导出数据，说明我们肯定有一个源头，一个目标，源头是我们的一个数据库，我们得先连接到这个数据库</p>
<h2 id="新建数据库连接"><a href="#新建数据库连接" class="headerlink" title="新建数据库连接"></a>新建数据库连接</h2><p>我们在主对象库中，DB连接上，右键单击，新建<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-07.png-blog.photo" alt="Kettle-handbook-02-07.png"><br>在这里呢，我们可以看到，有很多的数据库可以选择，我们只需要填写基本的连接信息就可以了<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-08.png-blog.photo" alt="Kettle-handbook-02-08.png"><br>我们这里连接的是Postgresql，配置好后，测试下，（坑，刚刚在windows上装的数据库，一直连不上，白名单都加好了，就是不行，结果是防火墙忘关了。。）<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-09.png-blog.photo" alt="Kettle-handbook-02-09.png"><br>好了，可以连接到数据库了，下面，我们得把数据导出啊，我们需要使用输入这个控件<br>输入下面，有很多的控件，我们这次只使用表输入，因为我们是直接从数据库中拿数据<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-10.png-blog.photo" alt="Kettle-handbook-02-10.png"><br>这里直接就是拖拽的，拖过去就行了，双击之后，可以编辑，这里我们就使用刚才的数据源连接，然后查询一张表，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-11.png-blog.photo" alt="Kettle-handbook-02-11.png"><br>表的话，随便create一张就可以了，我们还可以预览数据<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-12.png-blog.photo" alt="Kettle-handbook-02-12.png"><br>源头好了，同样的思路，我们需要一个目标，就是输出了，输出到Excel<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-13.png-blog.photo" alt="Kettle-handbook-02-13.png"><br>同样的，我们托好之后，双击就可以编辑了，这里，我们主要关注2个配置，一个是excel保存地址，和字段<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-14.png-blog.photo" alt="Kettle-handbook-02-14.png"><br>我们选择一个地址，然后得，看下字段那个tab，<br>我们单击，获取字段，就可以从源头获取表中的字段了，当然，我们可以只导出，我们需要的字段，<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-15.png-blog.photo" alt="Kettle-handbook-02-15.png"><br>一步一步来的话，上面获取，可能会获取不到，因为，有一步，需要将2个控件，连起来，源头有了，目标也有了，得让他们关联起来啊，再Kettle中，这个连线叫做Hop（跳），就像一个管道一样，将数据流从一个点，指向另一个点。<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-16.png-blog.photo" alt="Kettle-handbook-02-16.png"><br>都好了，以后，我们就运行下<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-17.png-blog.photo" alt="Kettle-handbook-02-17.png"><br>和Java里面，一样，绿色的话，就代表成功了<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-19.png-blog.photo" alt="Kettle-handbook-02-19.png"><br>我们看下文件<br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-18.png-blog.photo" alt="Kettle-handbook-02-18.png"><br>好了，我们的第一个例子，就成功了，还是很简单的，主要就是Kettle中控件的熟悉。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好了，我们先来看第一个例子，就是怎样将数据库中的数据，导出为Excel。&lt;br&gt;平时，如果我们需要将数据导出Excel的话，我们可能会直接复制，然后粘贴出来，但是数据量大的话，就不好用了；&lt;br&gt;或者使用Java等开发语言，写代码，导出Excel；或者一些数据库连接工具自带的导出功能。&lt;br&gt;其实，我们用Kettle的话，还是很方便的，但是平时用下来，Kettle的这个功能还是有些缺陷的，比如导出Excel2007+的时候，经常会报错，我一直也没有解决，这次记录博客顺便研究看看。&lt;/p&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;h1 id=&quot;1-Kettle的下载及使用&quot;&gt;&lt;a href=&quot;#1-Kettle的下载及使用&quot; class=&quot;headerlink&quot; title=&quot;1. Kettle的下载及使用&quot;&gt;&lt;/a&gt;1. Kettle的下载及使用&lt;/h1&gt;&lt;/div&gt;
&lt;p&gt;正式开始之前，我们简单说下Kettle的安装配置啥的，Kettle是绿色的，下载之后，直接运行就可以了&lt;br&gt;刚刚在网上下了个最新版的，后面，我们就是用这个7.0版本介绍官网地址：&lt;a href=&quot;http://community.pentaho.com/projects/data-integration/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kettle官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-02-01.png-blog.photo&quot; alt=&quot;Kettle-handbook-02-01.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ETL-Kettle" scheme="http://yoursite.com/categories/ETL-Kettle/"/>
    
    
      <category term="Kettle" scheme="http://yoursite.com/tags/Kettle/"/>
    
  </entry>
  
  <entry>
    <title>Kettle手册（一）- 序及Kettle简介</title>
    <link href="http://yoursite.com/2017/03/27/Kettle-handbook-01/"/>
    <id>http://yoursite.com/2017/03/27/Kettle-handbook-01/</id>
    <published>2017-03-27T13:59:00.000Z</published>
    <updated>2017-08-26T15:37:41.262Z</updated>
    
    <content type="html"><![CDATA[<div class="note primary"><h1 id="1-序"><a href="#1-序" class="headerlink" title="1. 序"></a>1. 序</h1></div>
<p>好久没有写博客了，新的一年总得留下点儿什么。目前主要负责数据仓库这一块任务，平时用用Kettle、SSIS这类ETL工具，而且工具的使用整理起来会方便些。所以先从Kettle开始，一点点整理下最近BI开发中掌握的知识。<br>以前有做过BI报表Cognos开发还有些入门级的Java，都在CSDN博客上，感兴趣的同学可以去看看：<a href="http://blog.csdn.net/yuguiyang1990" target="_blank" rel="external">于贵洋的博客</a><br><img src="http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-01-01.png-blog.photo" alt="Kettle-handbook-01Kettle-handbook-01-01"><br>好了，下面就根据自己的经验和理解，整理下Kettle的知识。</p>
<a id="more"></a>
<div class="note primary"><h1 id="2-Kettle简介"><a href="#2-Kettle简介" class="headerlink" title="2. Kettle简介"></a>2. Kettle简介</h1></div>
<p>Kettle这东西是干嘛的呢？<br>Kettle是一个开源的ETL工具，所以基本的数据抽取、转换、加载，他都可以。<br>比如：我要把一个mysql数据库的数据同步到一个Postgres数据库，我们有哪些办法呢?<br>大概会有:</p>
<ol>
<li>将数据导出为文本文件，使用PG的copy命令直接加载</li>
<li>数据量少的话，直接拼接成insert脚本，批量插入</li>
<li>一些开源的小工具，提供2种数据库直接的同步</li>
<li>Kettle</li>
</ol>
<p>等等方法<br>再比如：<br>我每天需要统计一些系统中的异常数据，导出为Excel，用邮件发送给指定的开发人员处理，该怎样做呢？</p>
<ol>
<li>Java或者其他开发语言做定时任务</li>
<li>Kettle   </li>
</ol>
<p>和其他的ETL工具相比，他有什么优势呢？</p>
<blockquote>
<p>Kettle是基于Java开发的，是开源免费的，大家可以直接在网上下载；<br>跨平台，Windows，Linux都可以使用；使用起来简单快捷。</p>
<p>既然开源，相比于其他收费产品，劣势也就很显然了，比如稳定性啊，BUG修复处理啊，而且基于Java，性能上会差些。<br>当然都是相对来说，一般数据量使用或者逻辑不复杂的话，使用起来是很适合的。</p>
</blockquote>
<p>刚刚也在社区上，发现了Kettle的视频，kettle视频，大家可以看看，应该用的到。<br>Kettle的基本介绍就这些，后面会根据实际的例子，来介绍下Kettle的使用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note primary&quot;&gt;&lt;h1 id=&quot;1-序&quot;&gt;&lt;a href=&quot;#1-序&quot; class=&quot;headerlink&quot; title=&quot;1. 序&quot;&gt;&lt;/a&gt;1. 序&lt;/h1&gt;&lt;/div&gt;
&lt;p&gt;好久没有写博客了，新的一年总得留下点儿什么。目前主要负责数据仓库这一块任务，平时用用Kettle、SSIS这类ETL工具，而且工具的使用整理起来会方便些。所以先从Kettle开始，一点点整理下最近BI开发中掌握的知识。&lt;br&gt;以前有做过BI报表Cognos开发还有些入门级的Java，都在CSDN博客上，感兴趣的同学可以去看看：&lt;a href=&quot;http://blog.csdn.net/yuguiyang1990&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;于贵洋的博客&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;http://7xl61k.com1.z0.glb.clouddn.com/Kettle-handbook-01-01.png-blog.photo&quot; alt=&quot;Kettle-handbook-01Kettle-handbook-01-01&quot;&gt;&lt;br&gt;好了，下面就根据自己的经验和理解，整理下Kettle的知识。&lt;/p&gt;
    
    </summary>
    
      <category term="ETL-Kettle" scheme="http://yoursite.com/categories/ETL-Kettle/"/>
    
    
      <category term="Kettle" scheme="http://yoursite.com/tags/Kettle/"/>
    
  </entry>
  
</feed>
